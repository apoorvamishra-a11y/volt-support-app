const https = require('https');

const APPS_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbyLB9Y9dXTltQz9oWB5-R6Lyi__qJkThuvWT_ncaQPb2uV4FkJ9LAPX6mHb3BnmqFCN/exec';

const PRE_LOAN_TYPES = [
  'login & mobile number registration',
  'kyc issue'
];

function getLoanCategory(type) {
  if (!type) return 'post';
  return PRE_LOAN_TYPES.includes(type.toLowerCase().trim()) ? 'pre' : 'post';
}

function fetchWithRedirect(url, count = 0) {
  return new Promise((resolve, reject) => {
    if (count > 5) return reject(new Error('Too many redirects'));
    https.get(url, (res) => {
      if ([301, 302, 307].includes(res.statusCode)) {
        return resolve(fetchWithRedirect(res.headers.location, count + 1));
      }
      let raw = '';
      res.on('data', c => raw += c);
      res.on('end', () => resolve(raw));
      res.on('error', reject);
    }).on('error', reject);
  });
}

module.exports = async (req, res) => {
  res.setHeader('Access-Control-Allow-Origin', '*');
  try {
    const raw = await fetchWithRedirect(APPS_SCRIPT_URL);
    const parsed = JSON.parse(raw);

    // Empty rows filter karo
    const clean = parsed.filter(row =>
      (row['Type'] && row['Type'].trim() !== '') ||
      (row['Sub Type'] && row['Sub Type'].trim() !== '')
    );

    // Merged cells fix â€” Type upar se fill karo neeche
    let lastType = '';
    const final = clean.map(row => {
      if (row['Type'] && row['Type'].trim() !== '') {
        lastType = row['Type'].trim();
      }
      return {
        type: lastType,
        subType: (row['Sub Type'] || '').trim(),
        preChecks: (row['Pre-checks'] || '').trim(),
        escalationPath: (row['Escalation Path'] || '').trim(),
        loanCategory: getLoanCategory(lastType)
      };
    });

    res.status(200).json(final);
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
};
